* Clojure-102

** 開始之前
*** 安裝 Leiningen
**** 如何安裝
1. Download the [[https://raw.githubusercontent.com/technomancy/leiningen/stable/bin/lein][lein script]] (or on Windows [[https://raw.githubusercontent.com/technomancy/leiningen/stable/bin/lein.bat][lein.bat]])
2. Place it on your $PATH where your shell can find it (eg. ~/bin)
3. Set it to be executable (chmod a+x ~/bin/lein)
4. Run it (lein) and it will download the self-install package

You can check your [[https://github.com/technomancy/leiningen/wiki/Packaging][package manager]] as well, but be sure you get version 2.x. 
There's also an [[http://leiningen-win-installer.djpowell.net/][installer for Windows users]].

**** 檢查安裝
#+NAME: lein repl
#+BEGIN_SRC
⋊> ~ lein version                                                  
Leiningen 2.6.0 on Java 1.8.0_25 Java HotSpot(TM) 64-Bit Server VM
⋊> ~ lein repl
nREPL server started on port 55836 on host 127.0.0.1 - nrepl://127.0.0.1:55836
REPL-y 0.3.7, nREPL 0.2.12
Clojure 1.8.0
Java HotSpot(TM) 64-Bit Server VM 1.8.0_25-b17
    Docs: (doc function-name-here)
          (find-doc "part-of-name-here")
  Source: (source function-name-here)
 Javadoc: (javadoc java-object-or-class-here)
    Exit: Control+D or (exit) or (quit)
 Results: Stored in vars *1, *2, *3, an exception in *e

user=> (println "hello, world!")
hello, world!
nil
user=> (+ 1 2)
3
user=> (defn add
  #_=>   [a b]
  #_=>   (+ a b))
#'user/add
user=> (add 1 2)
3
user=> (do (println "hello~")
  #_=>     (println "world!"))
hello~
world!
nil
user=> exit
Bye for now!
#+END_SRC

** 原生數據
*** 字串
**** 使用範例
#+NAME:
#+BEGIN_SRC
user=> (require '[clojure.string :as str])
nil
user=> (str/blank? "")
true
#+END_SRC

**** 改變字串大小寫

#+NAME:
#+BEGIN_SRC
;; 改變字串的第一個字符
user=> (clojure.string/capitalize "hi! i am walter")
"Hi! i am walter"

;; 改變字串的所有大寫
user=> (clojure.string/upper-case "become upper case")
"BECOME UPPER CASE"

;; 改變字串的所有小寫
user=> (clojure.string/lower-case "BECOME LOWER CASE")
"become lower case"

#+END_SRC

**** 清除字串的空白字符
#+NAME:
#+BEGIN_SRC
;; 刪除首尾的所有空白字符
user=> (clojure.string/trim " Hello, trim space ")
"Hello, trim space"
#+END_SRC

**** 建立字串
#+NAME:
#+BEGIN_SRC
;; 利用 str 建立字串
user=> (str "hi" ", " "I " "am " "Walter")
"hi, I am Walter"

;; 利用 apply 建立字串
user=> (apply str ["hi" ", " "I " "am " "Walter"])
"hi, I am Walter"

;; join
user=> (clojure.string/join '[a b c d])
"abcd"
#+END_SRC

**** 將字串做為字符序列
#+NAME:
#+BEGIN_SRC
;; 字用 seq
user=> (seq "hello, world!")
(\h \e \l \l \o \, \space \w \o \r \l \d \!)

;; 計算每個字符在字串中出現的次數
user=> (frequencies (str "This " "is " "an " "apple"))
{\space 3, \a 2, \e 1, \h 1, \i 2, \l 1, \n 1, \p 2, \s 2, \T 1}

;; 判斷字串中的每個字符是否都是大寫
user=> (defn is-upper? [s]
  #_=>   (every? #(or (not (Character/isLetter %))
  #_=>                (Character/isUpperCase %))
  #_=>         s))
#'user/is-upper?
user=> (is-upper? "ALL UPPER")
true
user=> (is-upper? "all upper")
false
#+END_SRC

**** 字符與數值轉換
#+NAME:
#+BEGIN_SRC
;; 用 int 將字符轉成整數值
user=> (int \a)
97
user=> (int \0)
48
user=> (map int "hello, world!")
(104 101 108 108 111 44 32 119 111 114 108 100 33)

;; 用 char 函數返回整數編碼值對應的字符
user=> (int \a)
97
user=> (int \0)
48
user=> (map int "hello, world!")
(104 101 108 108 111 44 32 119 111 114 108 100 33)
user=> (char 97)
\a
user=> (char 48)
\0
user=> (reduce #(str %1 (char %2))
  #_=>         ""
  #_=>         [72 101 108 108 111])
"Hello"
#+END_SRC

**** 格式化字串
#+NAME:
#+BEGIN_SRC
;; 使用 str
user=> (def my-name "walter")
#'user/my-name
user=> (str "My name is " my-name)
"My name is walter"
user=> (str "My age is " (+ 8 9))
"My age is 17"

;; 使用 format
user=> (format "My age is %02d" (+ 8 9))
"My age is 17"
#+END_SRC

**** 找尋字串
#+NAME:
#+BEGIN_SRC
;; 所有連續的數字
user=> (re-find #"\d+" "I am walter, i am 17 years old.")
"17"

;; 連續的單詞字符
user=> (re-find #"\w+" "I am walter")
"I"
user=> (re-find #"\w+" "hello-world")
"hello"
user=> (re-matches #"\w+" "I am walter")
nil
user=> (re-matches #"\w+" "IAmWalter")
"IAmWalter"
#+END_SRC

**** 正規表示法取值
#+NAME:
#+BEGIN_SRC
user=> (re-seq #"\w+" "I am walter")
("I" "am" "walter")
user=> (re-seq #"\w+\s" "I am walter")
("I " "am ")
user=> (re-seq #"\d{2}-\d{8}" "My phone number is 02-12345678")
("02-12345678")
user=> (re-find #"(\d{2})-(\d{8})" "My phone number is 02-12345678")
["02-12345678" "02" "12345678"]
#+END_SRC

**** 對字串查找和替換
#+NAME:
#+BEGIN_SRC
user=> (clojure.string/replace "I am 20 years old" "20" "18")
"I am 18 years old"
user=> (clojure.string/replace "I am 17 years old, not 18." #"(\d+)" "xx")
"I am xx years old, not xx."
#+END_SRC

**** 將字串切成部份
#+NAME:
#+BEGIN_SRC
user=> (clojure.string/split "I,am,walter" #",")
["I" "am" "walter"]
user=> (clojure.string/split "I am walter" #"\s+")
["I" "am" "walter"]

;; 設置 limit
user=> (clojure.string/split "I am walter" #"\s+" 1)
["I am walter"]
user=> (clojure.string/split "I am walter" #"\s+" 2)
["I" "am walter"]
user=> (clojure.string/split "I am walter" #"\s+" 100)
#+END_SRC

**** 在字串，符號和關鍵字間轉換
#+NAME:
#+BEGIN_SRC
;; 字串轉符號
user=> (symbol "vaild?")
vaild?

;; 符號轉字串
user=> (str 'vaild?)
"vaild?"

;; 關鍵字轉字串
user=> (name :wonderful)
"wonderful"

;; 關鍵字轉字串包含冒號
user=> (str :wonderful)
":wonderful"

;; 符號或字串轉成關鍵字
user=> (keyword "wonderful")
:wonderful
user=> (keyword 'wonderful)
:wonderful

;; 關鍵字轉成符號
user=> (symbol (name :wonderful))
wonderful

;; 取得關鍵字名字部份
user=> (name :user/vaild?)
"vaild?"

;; 取得命名空間
user=> (namespace :user/vaild?)
"user"
#+END_SRC

*** 數值
**** 利用非常大或非常小的數來保持精度
#+NAME:
#+BEGIN_SRC
;; 亞佛加厥常數
user=> 6.0221413e23
6.0221413E23

user=> 1e-10
1.0E-10

;; 超過 long 的邊界，溢位錯誤
user=> (* 9999 9999 9999 9999 9999)

ArithmeticException integer overflow  clojure.lang.Numbers.throwIntOverflow (Numbers.java:1501)

;; 使用引號提升到 Big 類型
user=> (*' 9999 9999 9999 9999 9999)
99950009999000049999N
#+END_SRC

**** 使用有理數
#+NAME:
#+BEGIN_SRC
user=> (/ 1 4)
1/4
user=> (type (/ 1 4))
clojure.lang.Ratio
user=> (* 2 (/ 1 2))
1N

;; double 類型
user=> (+ (/ 1 5) 0.7)
0.8999999999999999

;; 使用 rationalize 轉換成有理數，以免失去精度
user=> (rationalize 0.7)
7/10
user=> (+ (/ 1 5) (rationalize 0.7))
9/10
#+END_SRC

**** 解析數字
#+NAME:
#+BEGIN_SRC
;; 使用 Integer/parseInt
user=> (Integer/parseInt "33")
33

;; 使用 Double/parseDouble
user=> (Double/parseDouble "3.14159")
3.14159

;; 高精度 使用 BigInteger
user=> (bigint "1234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890")
1234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890N

;; 高精度 使用 BigDecimal
user=> (bigdec "3.141592653589793238462643383279502884197")
3.141592653589793238462643383279502884197M
#+END_SRC

**** 數字的載斷和捨入
#+NAME:
#+BEGIN_SRC
;; 強制轉成 int
user=> (int 3.14)
3
user=> (int 1.9988776655)
1

;; 取四拾五入
user=> (Math/round 3.14)
3
user=> (Math/round 1.9988776655)
2

;; 取得大於指定數的最小整數值
user=> (Math/ceil 1.9988776655)
2.0

;; 取得小於指定數的最大整數值
user=> (Math/floor 3.14)
3.0
#+END_SRC

**** 三角函數
#+NAME:
#+BEGIN_SRC
;; 計算 sin(a + b)
;; sin(a + b) = sin a * cos b + sin b * cos a
user=> (defn sin-plus [a b]
  #_=>   (+ (* (Math/sin a) (Math/cos b))
  #_=>      (* (Math/sin b) (Math/cos a))))
#'user/sin-plus
user=> (sin-plus 0.1 0.3)
0.38941834230865047
#+END_SRC

**** 根據不同的進制輸入與輸出整數
#+NAME:
#+BEGIN_SRC
user=> 2r00111100
60
user=> 2r11111111
255
user=> 16r0A
10
user=> 16r10
16

;; 輸出整數
user=> (Integer/toString 10 2)
"1010"
user=> (Integer/toString 10 16)
"a"
#+END_SRC

**** 計算數值集合的統計值
#+NAME:
#+BEGIN_SRC
#'user/main
user=> (defn mean [coll]
  #_=>   (let [sum (apply + coll)
  #_=>         count (count coll)]
  #_=>     (if (pos? count)
  #_=>       (/ sum count)
  #_=>       0)))
#'user/mean
user=> (mean [1 2 3 4])
5/2
user=> (mean [1 2 3])
2
user=> (mean [1.1 2.2 3.3 4.4])
2.75
#+END_SRC

**** 找出數值的中位數
#+NAME:
#+BEGIN_SRC
user=> (defn median [coll]
  #_=>   (let [sorted (sort coll)
  #_=>         cnt (count sorted)
  #_=>         halfway (int (/ cnt 2))]
  #_=>     (if (odd? cnt)
  #_=>       (nth sorted halfway)
  #_=>       (let [bottom (dec halfway)
  #_=>             bottom-val (nth sorted bottom)
  #_=>             top-val (nth sorted halfway)]
  #_=>         (mean [bottom-val top-val])))))
#'user/median
user=> (median [1 3 4 2 5])
3
user=> (median [2 0 1 4])
3/2
#+END_SRC

**** 找出集合中最常出現的值
#+NAME:
#+BEGIN_SRC
user=> (defn mode [coll]
  #_=>   (let [freqs (frequencies coll)
  #_=>         occurrences (group-by second freqs)
  #_=>         modes (last (sort occurrences))
  #_=>         modes (->> modes
  #_=>                    second
  #_=>                    (map first))]
  #_=>     modes))
#'user/mode
user=> (mode [:walter :qq :walter :gg])
(:walter)
user=> (mode [:walter :qq :walter :gg :qq])
(:walter :qq)
#+END_SRC

**** 生成隨機數
#+NAME:
#+BEGIN_SRC
user=> (rand)
0.2824352415380432
user=> (rand)
0.8155379471470274

;; 生成隨機整數
user=> (inc (rand-int 6))
6
user=> (inc (rand-int 6))
1
user=> (inc (rand-int 6))
5

;; 從序列集合取得隨機元素
user=> (rand-nth [1 2 3])
3
user=> (rand-nth [1 2 3])
1
user=> (rand-nth '(:a :b :c))
:c
user=> (rand-nth '(:a :b :c))
:b

;; 對 set 或 hashmap 取得隨機元素
;; 如果單純使用的話，無法對 set 或 hashmap 起作用，請先使用 seq 將其轉成序列
user=> (rand-nth (seq #{:walter :qq :gg :hello}))
:walter
user=> (rand-nth (seq #{:walter :qq :gg :hello}))
:gg

;; 隨機排列一個集合
user=> (shuffle [1 2 3 4 5 6 7 8 9 0])
[3 4 9 7 6 0 2 5 1 8]
user=> (shuffle [1 2 3 4 5 6 7 8 9 0])
[4 2 7 1 8 9 0 5 6 3]
#+END_SRC

**** 生成唯一ID
#+NAME:
#+BEGIN_SRC
user=> (java.util.UUID/randomUUID)
#uuid "cdeaf476-17d8-48e6-b8b3-841de13c9834"
user=> (java.util.UUID/randomUUID)
#uuid "0b66be93-e853-4f63-95e0-c3be5f9e9066"
#+END_SRC

*** 日期
